/**
 * LR parser generated by the Syntax tool.
 *
 * To regenerate run:
 *
 *   ./bin/syntax \
 *     --grammar ~/path-to-grammar-file
 *     --output ~/path-to-output-file.js
 *
 * In case of custom tokeninzer, one may pass --use-custom-tokinzer option.
 */

'use strict';

let yytext;
let yyleng;
let $$;

const EOF = {
  toString() {
    return '$';
  }
};

const productions = <<PRODUCTIONS>>;
const table = <<TABLE>>;

let stack = [];

function unexpectedToken(token) {
  if (token.value === EOF) {
    unexpectedEndOfInput();
  }
  parseError(`Unexpected token: ${token.value}.`);
}

function unexpectedEndOfInput() {
  parseError(`Unexpected end of input.`);
}

function parseError(message) {
  throw new Error(`Parse error: ${message}`);
}

let tokenizer;
<<TOKENIZER>>

const LRParser = {
  parse(string) {
    if (!tokenizer) {
      throw new Error(
        `Tokenizer instance wasn't specified. ` +
        'Use `parser.setTokenizer(tokenizerInstance);`' +
        `or generate the parser with the default tokenizer.`
      );
    }

    tokenizer.initString(string);

    stack = [];

    stack.push(0);

    let token = tokenizer.getNextToken();
    let shiftedToken = null;

    do {
      if (!token) {
        unexpectedEndOfInput();
      }

      let state = stack[stack.length - 1];
      let column = token.type;
      let entry = table[state][column];

      if (!entry) {
        unexpectedToken(token);
      }

      if (entry[0] === 's') {
        stack.push(
          {symbol: token.type, semanticValue: token.value},
          Number(entry.slice(1))
        );
        shiftedToken = token;
        token = tokenizer.getNextToken();
      } else if (entry[0] === 'r') {
        let productionNumber = entry.slice(1);
        let production = productions[productionNumber];
        let hasSemanticAction = typeof production[2] === 'function';
        let semanticActionArgs = hasSemanticAction ? [] : null;

        if (production[1] !== 0) {
          let rhsLengh = production[1];
          while (rhsLengh--) {
            stack.pop();
            let stackEntry = stack.pop();

            if (hasSemanticAction) {
              semanticActionArgs.unshift(stackEntry.semanticValue);
            }
          }
        }

        let reduceStackEntry = {symbol: production[0]};

        if (hasSemanticAction) {
          yytext = shiftedToken ? shiftedToken.value : null;
          yyleng = shiftedToken ? shiftedToken.value.length : null;

          production[2](...semanticActionArgs);
          reduceStackEntry.semanticValue = $$;
        }

        stack.push(
          reduceStackEntry,
          table[stack[stack.length - 1]][production[0]]
        );
      } else if (entry === 'acc') {
        stack.pop();
        let parsed = stack.pop();

        if (stack.length !== 1 ||
            stack[0] !== 0 ||
            tokenizer.hasMoreTokens()) {
          unexpectedToken(token);
        }

        if (parsed.hasOwnProperty('semanticValue')) {
          return parsed.semanticValue;
        }

        return true;
      }

    } while (tokenizer.hasMoreTokens() || stack.length > 1);
  },

  setTokenizer(customTokenizer) {
    tokenizer = customTokenizer;
    return this;
  },

  getTokenizer() {
    return tokenizer;
  },

};

module.exports = LRParser;
