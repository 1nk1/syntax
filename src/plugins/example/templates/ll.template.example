/**
 * LL parser for Example language generated by the Syntax tool.
 *
 * https://www.npmjs.com/package/syntax-cli
 *
 *   npm install -g syntax-cli
 *
 *   syntax-cli --help
 *
 * To regenerate run:
 *
 *   syntax-cli \
 *     --grammar ~/path-to-grammar-file \
 *     --mode LL1 \
 *     --output ~/ParserClassName.example
 */

// --------------------------------------------------------------
// Global variable EOF

/**
 * A special "end of file" symbol, used by tokenizer as well.
 */
const EOF = "$";

// --------------------------------------------------------------
// Tokenizer.

/**
 * Tokenizer class.
 */
<<TOKENIZER>>

// --------------------------------------------------------------
// Productions array.

/**
 * Encoded grammar productions table, array of arrays.
 *
 * Format of an entry array:
 *
 * <Production Number>: [ <Indexes of RHS.reverse()> ]
 *
 * LL-algorithm uses reversed RHS to do derivation, and push the RHS symbols
 * onto the stack to replace a non-terminal; this reversed RHS is stored as the
 * second element of a record. The first element is a special marker [-1],
 * since production numbers are 1-based.
 *
 * NOTE: LL parser doesn't implement a semantic action; use LR parser for this.
 *
 * Example:
 *
 * [
 *     [-1],
 *     [1, 2],
 *     [1, 2, 5],
 *     ...
 * ]
 */
const productions = <<PRODUCTIONS>>;

// --------------------------------------------------------------
// Parsing table.

/**
 * An array of records, where index is a Non-terminal index, and a value is a
 * map from an encoded terminal (number) to the next production number.
 *
 * Example:
 *
 * [
 *   // 0
 *   {
 *     7: 1,
 *     8: 1,
 *   },
 *   // 1
 *   {
 *     5: 2,
 *     9: 3,
 *     3: 4,
 *   },
 *   ...
 * ]
 */
const table = <<TABLE>>;

// --------------------------------------------------------------
// Parsing stack.

/**
 * Parsing stack. Stores instances of StackEntry, and state numbers.
 */
let stack = [];

// --------------------------------------------------------------
// Global variable __

/**
 * __ holds a result value from a production
 * handler. In the grammar usually used as $$.
 */
let __ = null;

// --------------------------------------------
// Parser.

/**
 * Base class for the parser. Implements LL parsing algorithm.
 *
 * Should implement at least the following API:
 *
 * - parse(string stringToParse): object
 * - setTokenizer(Tokenizer tokenizer): void, or equivalent Tokenizer
 *   accessor property with a setter.
 */
class yyparse {

  constructor() {
    // A tokenizer instance, which is reused for all
    // `parse` method calls. The actual string is set
    // in the tokenizer.initString("...").
    this.tokenizer = new Tokenizer();
  }

  /**
   * On parse begin callback.
   *
   * Example: yyparse.onParseBegin = (code) => { ... };
   *
   * Default is empty, but callers (including in module include) can override.
   */
  onParseBegin() {}

  /**
   * On parse end callback.
   *
   * Example: yyparse.onParseEnd = (value) => { ... };
   *
   * Default is empty, but callers (including in module include) can override.
   */
  onParseEnd() {}

  /**
   * Production handles. The handlers receive arguments as _1, _2, etc.
   * The result is always stored in __.
   *
   * Example:
   *
   * _handler1(_1, _2, _3) {
   *   __ = _1 + _3;
   * }
   */
  <<PRODUCTION_HANDLERS>>

  /**
   * Main parsing method which applies LR-algorithm.
   */
  parse(str) {
    // On parse begin hook.
    this.onParseBegin(str);

    // Tokenizer should be set prior calling the parse.
    if (!this.tokenizer) {
      throw new Error("Tokenizer instance isn't specified.");
    }

    this.tokenizer.initString(str);

    // Initialize the parsing stack to contain EOF at the bottom,
    // and the Start symbol (always encoded as 0).
    stack = [
      EOF,
      0, // Start symbol.
    ];

    let token = this.tokenizer.getNextToken();

    // Top of the stack.
    let top = null;

    // Main parsing loop.
    do {
      top = stack.pop();

      // If a terminal is on top of the stack, just move forward.
      if (top === token.type) {
        token = this.tokenizer.getNextToken();
        continue;
      }

      // Else, it is a Non-terminal on top of the stack,
      // do derivation (replace the non-terminal with its
      // reversed RHS)
      this._doDerivation(top, token);

    } while (this.tokenizer.hasMoreTokens() || stack.length > 1);

    while (stack.length !== 1) {
      this._doDerivation(stack.pop(), token);
    }

    if (stack[0] !== EOF || token.value !== EOF) {
      this.parseError(`stack is not empty: ${stack}, ${token.value}`);
    }

    return true;
  }

  _doDerivation(top, token) {
    let nextProductionNumber = table[top][token.type];

    // No derivation.
    if (!nextProductionNumber) {
      this.unexpectedToken(t);
    }

    // Push RHS (stored at index 0) of the Non-terminal on the stack.
    stack.push(...productions[nextProductionNumber][0]);
  }

  unexpectedToken(token) {
    if (token.value == EOF) {
      this.unexpectedEndOfInput();
    }

    this.tokenizer.throwUnexpectedToken(
      token.value,
      token.startLine,
      token.startColumn
    );
  }

  unexpectedEndOfInput() {
    this.parseError("Unexpected end of input.");
  }

  parseError(message) {
    throw new SyntaxError(message);
  }
}

// --------------------------------------------------------------
// Module include.

/**
 * Module include may contains any arbitrary code (usually import/require
 * statements which include classes for AST nodes, etc). The code is directly
 * included to the output generated file. It may also contain callbacks
 * for parsing hooks, such as `onParseBegin`, `onParseEnd`, etc.
 */
<<MODULE_INCLUDE>>

/**
 * An actual parser class.
 */
module.exports = class <<PARSER_CLASS_NAME>> extends yyparse {};